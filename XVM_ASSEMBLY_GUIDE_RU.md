# XVM Assembly — Руководство по написанию и редактированию скриптов

## Содержание

1. [Обзор](#обзор)
2. [Формат .dis файла](#формат-dis-файла)
3. [Заголовок модуля](#заголовок-модуля)
4. [Объявление функций](#объявление-функций)
5. [Инструкции — полный справочник](#инструкции--полный-справочник)
6. [Метки и переходы](#метки-и-переходы)
7. [Стековая машина — как работает XVM](#стековая-машина--как-работает-xvm)
8. [Типы данных](#типы-данных)
9. [Комментарии](#комментарии)
10. [Практические примеры](#практические-примеры)
11. [Workflow: дизассемблирование → редактирование → сборка](#workflow)
12. [Ограничения](#ограничения)
13. [Частые ошибки](#частые-ошибки)

---

## Обзор

**XVM** (Apex eXtensible Virtual Machine) — скриптовая виртуальная машина движка Apex Engine,
используемая в игре Mad Max. Скрипты компилируются в байткод `.xvmc` и управляют
игровой логикой: обработку урона, поведение AI, интерфейс, транспорт и т.д.

**Цепочка инструментов:**

```
.xvmc (бинарный)  ──XvmDisassemble──►  .dis (текстовый)
                                            │
                                        [редактирование]
                                            │
.xvmc (бинарный)  ◄──XvmAssemble────  .dis (текстовый)
```

Файл `.dis` — это текстовый ассемблер, который можно читать и редактировать
в любом текстовом редакторе.

---

## Формат .dis файла

Файл `.dis` состоит из трёх частей:

```
┌─────────────────────────┐
│   Заголовок модуля      │  ; name: ..., ; name_hash: ..., и т.д.
├─────────────────────────┤
│   Функция 1             │  == FuncName ==  + инструкции
├─────────────────────────┤
│   Функция 2             │  == FuncName ==  + инструкции
├─────────────────────────┤
│   ...                   │
└─────────────────────────┘
```

---

## Заголовок модуля

Заголовок модуля — это строки-комментарии в начале файла:

```asm
; === XVM Module ===
; name: bullet_damage_handler
; name_hash: 0xC167E9CD
; source_hash: 0x3E12DA24
; flags: 0x0
; size: 0
; functions: 2
; constants: 39
; string_hashes: 36
```

### Обязательные поля

| Поле | Формат | Описание |
|------|--------|----------|
| `name` | строка | Имя модуля (для отладки) |
| `name_hash` | `0xHEX` | Хеш имени модуля |
| `source_hash` | `0xHEX` | Хеш исходного файла |
| `flags` | `0xHEX` | Флаги модуля (обычно `0x0`) |
| `size` | число | Размер модуля (обычно `0`) |

### Информационные поля (игнорируются ассемблером)

| Поле | Описание |
|------|----------|
| `functions` | Количество функций (вычисляется автоматически) |
| `constants` | Количество констант (вычисляется автоматически) |
| `string_hashes` | Количество строковых хешей (вычисляется автоматически) |

> **Совет:** При создании нового модуля с нуля, `name_hash` и `source_hash`
> можно взять из существующего файла или задать произвольно.

---

## Объявление функций

Каждая функция начинается с заголовка и метаданных:

```asm
== HitByBullet ==
; hash: 0xC9716879  args: 3  locals: 7  max_stack: 9
```

### Заголовок функции

```
== ИмяФункции ==
```

Имя функции — произвольный идентификатор. Используется для отладки и
для вызова из других скриптов через `ldglob`.

### Метаданные функции

```
; hash: 0xHASH  args: N  locals: N  max_stack: N
```

| Поле | Описание |
|------|----------|
| `hash` | Хеш имени функции (должен соответствовать имени) |
| `args` | Количество аргументов функции |
| `locals` | Общее количество локальных переменных (включая аргументы) |
| `max_stack` | Максимальная глубина стека при выполнении |

> **Важно:** `locals` включает аргументы! Если функция принимает 3 аргумента
> и использует 4 локальные переменные, `locals = 7`.
>
> Локальные переменные 0..args-1 — это аргументы, args..locals-1 — локальные.

### Вычисление max_stack

`max_stack` — максимальное количество значений на стеке в любой точке функции.
Неправильное значение может привести к крашу. Правило: считайте пиковую глубину
стека, пройдя по всем путям выполнения.

Ориентировочно: посмотрите самую длинную цепочку `ld*` инструкций подряд
(без `pop`/`call`/`stloc`) — это минимальная оценка.

---

## Инструкции — полный справочник

Каждая инструкция записывается на отдельной строке:

```
    ADDR: мнемоника [операнд]
```

Адрес `ADDR` — четырёхзначный hex (например `0000:`, `001F:`) — необязателен,
ассемблер его игнорирует. Можно писать просто мнемонику:

```asm
    ldloc 0
    ldglob "scriptgo"
    ldattr "GetProperties"
    call 1
    stloc 3
```

### Группа 1: Загрузка значений на стек

| Мнемоника | Операнд | Стек | Описание |
|-----------|---------|------|----------|
| `ldloc N` | индекс | → val | Загрузить локальную переменную / аргумент |
| `ldfloat X` | число | → float | Загрузить число с плавающей точкой |
| `ldstr "text"` | строка | → string | Загрузить строковую константу |
| `ldbool N` | 0 или 1 | → bool | Загрузить булево значение |
| `ldnone` | — | → none | Загрузить None |
| `ldbytes XX YY..` | hex байты | → bytes | Загрузить сырые байты (хеш события и т.д.) |
| `ldglob "name"` | строка | → val | Загрузить глобальный объект |
| `ldattr "name"` | строка | val → val | Загрузить атрибут объекта |
| `lditem` | — | obj, idx → val | Загрузить элемент по индексу |

### Группа 2: Сохранение значений

| Мнемоника | Операнд | Стек | Описание |
|-----------|---------|------|----------|
| `stloc N` | индекс | val → | Сохранить в локальную переменную |
| `stattr "name"` | строка | obj, val → | Установить атрибут объекта |
| `stitem` | — | obj, idx, val → | Установить элемент по индексу |

### Группа 3: Арифметика и сравнения

| Мнемоника | Стек | Описание |
|-----------|------|----------|
| `add` | a, b → result | Сложение (a + b) |
| `sub` | a, b → result | Вычитание (a - b) |
| `mul` | a, b → result | Умножение (a * b) |
| `div` | a, b → result | Деление (a / b) |
| `mod` | a, b → result | Остаток от деления (a % b) |
| `neg` | a → result | Унарный минус (-a) |
| `cmpeq` | a, b → bool | Равно (a == b) |
| `cmpne` | a, b → bool | Не равно (a != b) |
| `cmpg` | a, b → bool | Больше (a > b) |
| `cmpge` | a, b → bool | Больше или равно (a >= b) |

### Группа 4: Логические операции

| Мнемоника | Стек | Описание |
|-----------|------|----------|
| `and` | a, b → bool | Логическое И |
| `or` | a, b → bool | Логическое ИЛИ |
| `not` | a → bool | Логическое НЕ |

### Группа 5: Управление потоком

| Мнемоника | Операнд | Стек | Описание |
|-----------|---------|------|----------|
| `jmp label_N` | метка | — | Безусловный переход |
| `jz label_N` | метка | val → | Переход если значение ложно (0 / false / None) |
| `call N` | кол-во арг | obj, arg1..argN → result | Вызов метода/функции |
| `ret N` | 0 или 1 | [val] → | Возврат из функции (0 = без значения, 1 = с значением) |

### Группа 6: Разное

| Мнемоника | Операнд | Стек | Описание |
|-----------|---------|------|----------|
| `pop` | — | val → | Убрать верхнее значение со стека |
| `mklist N` | количество | elem1..elemN → list | Создать список из N элементов |
| `assert` | — | val → | Проверка утверждения (крашит если false) |
| `dbgout N` | число | val → | Отладочный вывод |

---

## Метки и переходы

Метки определяют точки перехода для инструкций `jmp` и `jz`:

```asm
    ldloc 4
    ldfloat 1
    cmpeq
    jz label_skip         ; если не равно — прыгаем на label_skip

    ; этот код выполняется если равно
    ldfloat 42
    stloc 5

label_skip:
    ; продолжение — сюда попадаем в обоих случаях
    ldloc 5
    ret 1
```

### Правила меток

- Имя метки — произвольное, заканчивается двоеточием `:`
- Принятое соглашение: `label_XX` где XX — адрес целевой инструкции
- Метка должна быть объявлена на отдельной строке
- Метка не занимает инструкцию (не увеличивает счётчик адресов)
- Метка действует только внутри своей функции

```
label_10:              ← определение метки (не инструкция)
    0007: ldloc 3      ← инструкция с адресом 7
```

---

## Стековая машина — как работает XVM

XVM — **стековая** виртуальная машина. Все операции работают через стек:

```
Пример: вычисление (a + b) * c

    ldloc 0        ; стек: [a]
    ldloc 1        ; стек: [a, b]
    add            ; стек: [a+b]
    ldloc 2        ; стек: [a+b, c]
    mul            ; стек: [(a+b)*c]
    stloc 3        ; стек: []  → результат в переменной 3
```

### Вызов методов

Вызов метода — особый паттерн. Сначала на стек кладётся объект (вызываемый),
затем аргументы, затем `call N`:

```asm
; Эквивалент Python: game.SetHitByPlayer(target)

    ldloc 1              ; стек: [target]         — аргумент
    ldglob "game"        ; стек: [target, game]   — объект с методом
    ldattr "SetHitByPlayer" ; стек: [target, game.SetHitByPlayer] — метод
    call 1               ; стек: [result]          — вызов с 1 аргументом
    pop                   ; стек: []               — отбрасываем результат
```

> **Важно:** Порядок в стеке — аргументы кладутся ПЕРЕД объектом/методом.
> `call N` снимает со стека: вызываемый объект + N аргументов, кладёт результат.

### Вызов с несколькими аргументами

```asm
; Эквивалент: vehicle.GetPartByShapeKey(target, shapeKey)

    ldloc 1              ; стек: [target]          — arg1
    ldloc 2              ; стек: [target, shapeKey] — arg2 (из атрибута)
    ldattr "ShapeKey"    ; стек: [target, shapeKey_val]
    ldglob "vehicle"     ; стек: [target, shapeKey_val, vehicle]
    ldattr "GetPartByShapeKey"  ; стек: [target, shapeKey_val, method]
    call 2               ; стек: [result]
    stloc 5              ; стек: []  → результат в переменной 5
```

### Чтение атрибута (свойства)

```asm
; Эквивалент: x = obj.SomeProperty

    ldloc 0              ; стек: [obj]
    ldattr "SomeProperty" ; стек: [obj.SomeProperty]  — ldattr заменяет верхушку
    stloc 1              ; стек: []  → x = результат
```

> **ldattr** — снимает объект с верхушки стека, кладёт значение его атрибута.
> Это НЕ добавление на стек, а ЗАМЕНА верхнего элемента.

---

## Типы данных

### Числа с плавающей точкой (float)

```asm
    ldfloat 0           ; 0.0
    ldfloat 1           ; 1.0
    ldfloat 3.14        ; 3.14
    ldfloat -5          ; -5.0
    ldfloat 0.001       ; 0.001
```

XVM использует числа float повсюду — для целых тоже (0, 1, 2...).
Нет отдельного целочисленного типа для значений.

### Строки

```asm
    ldstr "Hello World"           ; обычная строка
    ldstr "Line1\nLine2"          ; с escape-последовательностями
    ldstr "She said \"hi\""       ; с кавычками
    ldstr "Tab\there"             ; с табуляцией
```

Поддерживаемые escape-последовательности: `\"`, `\\`, `\n`, `\r`, `\t`.

### Булевы значения

```asm
    ldbool 0             ; false
    ldbool 1             ; true
```

### None

```asm
    ldnone               ; None / null
```

### Сырые байты

```asm
    ldbytes 17 21 32 F3  ; 4 байта в hex
```

Используются для хешей событий, идентификаторов и т.д.

### Глобальные объекты

Встроенные глобальные объекты движка (доступны через `ldglob`):

| Объект | Описание |
|--------|----------|
| `"game"` | Игровой контекст |
| `"vehicle"` | Текущий транспорт |
| `"physics"` | Физический движок |
| `"debug"` | Отладочный вывод |
| `"scriptgo"` | Скриптовый игровой объект |

---

## Комментарии

Комментарии начинаются с `;` и продолжаются до конца строки:

```asm
    ldloc 0        ; загрузить первый аргумент (self)
    ldloc 1        ; arg1 — цель попадания
    ldfloat 5      ; тип боеприпаса: снайперский
```

Комментарии внутри строк не обрабатываются:

```asm
    ldstr "Hello ; World"   ; это один комментарий, строка = "Hello ; World"
```

---

## Практические примеры

### Пример 1: Условие if-else

```python
# Исходный псевдокод:
# if ammo_type == 5:
#     is_sniper = 1
```

```asm
    ; if ammo_type == 5
    ldloc 2                    ; bullet_info (arg2)
    ldattr "AmmunitionType"    ; bullet_info.AmmunitionType
    ldfloat 5                  ; 5 (снайперский тип)
    cmpeq                      ; AmmunitionType == 5 ?
    jz label_skip_sniper       ; если нет — пропустить

    ; is_sniper = 1
    ldfloat 1
    stloc 4                    ; is_sniper = 1

label_skip_sniper:
    ; продолжение кода...
```

### Пример 2: if-else с двумя ветками

```python
# if health > 50:
#     status = 1
# else:
#     status = 0
```

```asm
    ldloc 0
    ldattr "health"
    ldfloat 50
    cmpg                       ; health > 50 ?
    jz label_else              ; если нет — в else

    ; then: status = 1
    ldfloat 1
    stloc 1
    jmp label_endif

label_else:
    ; else: status = 0
    ldfloat 0
    stloc 1

label_endif:
    ; продолжение...
```

### Пример 3: Составное условие (AND)

```python
# if broadcastSniperHits == 1 and AmmunitionType == 5:
#     is_sniper = 1
```

```asm
    ; Первое условие
    ldloc 3                        ; properties
    ldattr "broadcastSniperHits"
    ldfloat 1
    cmpeq                          ; broadcastSniperHits == 1

    ; Второе условие
    ldloc 2                        ; bullet_info
    ldattr "AmmunitionType"
    ldfloat 5
    cmpeq                          ; AmmunitionType == 5

    ; Логическое И
    and                            ; condition1 AND condition2
    jz label_not_sniper            ; если false — пропустить

    ldfloat 1
    stloc 4                        ; is_sniper = 1

label_not_sniper:
```

### Пример 4: Вызов метода с форматированным выводом

```python
# debug.LogInfo("Damage: %f", bullet.Damage)
```

```asm
    ldstr "Damage: %f"        ; формат-строка
    ldloc 0                   ; bullet_info
    ldattr "Damage"           ; bullet_info.Damage
    mklist 1                  ; создать список из 1 аргумента: [Damage]
    ldglob "debug"            ; глобальный объект debug
    ldattr "LogInfo"          ; debug.LogInfo
    call 2                    ; вызов (2 аргумента: формат + список)
    pop                       ; отбросить результат
```

### Пример 5: Проверка null и вложенные условия

```python
# part = vehicle.GetPartByShapeKey(target, bullet.ShapeKey)
# if part is not None:
#     weakspot = part.LinkedGameObject
#     if weakspot is not None:
#         physics.WeakspotOnHitByBullet(weakspot, bullet)
```

```asm
    ; part = vehicle.GetPartByShapeKey(target, shapeKey)
    ldloc 1                    ; target (arg1)
    ldloc 2                    ; bullet_info (arg2)
    ldattr "ShapeKey"          ; bullet_info.ShapeKey
    ldglob "vehicle"
    ldattr "GetPartByShapeKey"
    call 2
    stloc 5                    ; part = результат

    ; if part is not None
    ldloc 5
    jz label_no_part           ; jz переходит если None/false/0

    ; weakspot = part.LinkedGameObject
    ldloc 5
    ldattr "LinkedGameObject"
    stloc 6

    ; if weakspot is not None
    ldloc 6
    jz label_no_weakspot

    ; physics.WeakspotOnHitByBullet(weakspot, bullet)
    ldloc 6                    ; weakspot — arg1
    ldloc 2                    ; bullet_info — arg2
    ldglob "physics"
    ldattr "WeakspotOnHitByBullet"
    call 2
    pop

label_no_weakspot:
label_no_part:
    ; продолжение...
```

### Пример 6: Отправка события

```asm
    ; scriptgo.SendEvent(self, event_hash)
    ldloc 0                    ; self (arg0)
    ldbytes 17 21 32 F3        ; хеш события (4 байта)
    ldglob "scriptgo"
    ldattr "SendEvent"
    call 2
    pop
```

### Пример 7: Создание новой функции

```asm
== MyCustomFunction ==
; hash: 0x12345678  args: 2  locals: 3  max_stack: 5

    ; arg0 = self, arg1 = target
    ; local 2 = temporary

    ldloc 1              ; target
    ldattr "Health"      ; target.Health
    ldfloat 10
    sub                  ; Health - 10
    stloc 2              ; temp = Health - 10

    ldloc 2
    ldfloat 0
    cmpg                 ; temp > 0 ?
    jz label_dead

    ; Цель жива — установить новое здоровье
    ldloc 1
    ldloc 2
    stattr "Health"      ; target.Health = temp
    jmp label_end

label_dead:
    ; Цель мертва
    ldloc 1
    ldfloat 0
    stattr "Health"      ; target.Health = 0

label_end:
    ret 0                ; возврат без значения
```

---

## Workflow

### Шаг 1: Извлечь скрипт из игры

Скрипты `.xvmc` находятся внутри ADF-контейнеров. Используйте инструменты
Gibbed.MadMax для извлечения.

### Шаг 2: Дизассемблировать

```
Gibbed.MadMax.XvmDisassemble.exe bullet_damage_handler.xvmc
```

Создаст `bullet_damage_handler.dis`.

### Шаг 3: Редактировать .dis

Откройте `.dis` в текстовом редакторе. Рекомендуется редактор с подсветкой
синтаксиса ASM (VSCode, Notepad++, Sublime Text).

**Что можно менять:**
- Инструкции внутри функций
- Значения констант (`ldfloat`, `ldstr`, `ldbool`)
- Условия (`cmpeq`, `cmpg`, `jz`, `jmp`)
- Добавлять/удалять инструкции
- Добавлять новые функции

**Что нужно обновлять при изменениях:**
- `locals` — если добавили новые локальные переменные
- `max_stack` — если изменилась пиковая глубина стека
- Метки — если изменились адреса переходов
- Адреса (XXXX:) — необязательны, ассемблер их игнорирует

### Шаг 4: Ассемблировать обратно

```
Gibbed.MadMax.XvmAssemble.exe bullet_damage_handler.dis
```

Создаст `bullet_damage_handler.xvmc`.

### Шаг 5: Проверить (опционально)

Дизассемблируйте новый `.xvmc` и сравните с исходным `.dis`:

```
Gibbed.MadMax.XvmDisassemble.exe bullet_damage_handler.xvmc bullet_damage_handler_check.dis
```

Файлы `.dis` должны быть идентичны (round-trip).

### Шаг 6: Упаковать и вставить в игру

Замените оригинальный `.xvmc` в ресурсах игры модифицированным.

---

## Ограничения

### Ограничения ассемблера

| Ограничение | Значение | Причина |
|-------------|----------|---------|
| Макс. констант | 2047 | Операнд 11 бит |
| Макс. инструкций на функцию | 2047 | Операнд 11 бит |
| Макс. локальных переменных | 2047 | Операнд 11 бит |
| Макс. глубина стека | 65535 | 16-бит поле |
| Макс. аргументов call | 2047 | Операнд 11 бит |
| Длина строки | 255 | 8-бит поле Length |

### Формат инструкции

Каждая инструкция — 16 бит:

```
[15       5][4    0]
 операнд    опкод
 (11 бит)   (5 бит)
```

- **5 бит опкод** → 32 возможных инструкции (используются 30)
- **11 бит операнд** → значения 0–2047

### debug_info не восстанавливается

Ассемблер не генерирует блок `debug_info` (маппинг инструкций на строки
исходного файла). Это не влияет на работу скрипта — `debug_info`
используется только для отладочных сообщений об ошибках.

---

## Частые ошибки

### 1. Забыли `pop` после `call`

```asm
    ; НЕПРАВИЛЬНО — результат остаётся на стеке!
    ldloc 0
    ldglob "game"
    ldattr "DoSomething"
    call 1

    ; ПРАВИЛЬНО
    ldloc 0
    ldglob "game"
    ldattr "DoSomething"
    call 1
    pop                    ; убрать неиспользуемый результат
```

Если результат `call` не нужен — обязательно `pop`. Иначе стек
будет расти, и `max_stack` окажется неверным.

### 2. Неправильный порядок аргументов call

```asm
    ; НЕПРАВИЛЬНО — аргументы должны быть ПЕРЕД объектом
    ldglob "game"
    ldattr "Method"
    ldloc 0               ; arg1 после метода — ОШИБКА
    call 1

    ; ПРАВИЛЬНО
    ldloc 0               ; arg1 — кладём сначала
    ldglob "game"
    ldattr "Method"        ; метод — кладём последним
    call 1
```

### 3. Неверный `max_stack`

Если `max_stack` меньше реальной глубины стека — возможен краш.
Лучше указать с запасом, чем слишком мало.

### 4. Неверный `locals`

`locals` должен включать все аргументы + все локальные переменные.
Если функция имеет `args: 3` и использует `stloc 5`, то `locals`
должен быть **минимум 6** (индексы 0–5).

### 5. Несуществующая метка

```asm
    jz label_42            ; ОШИБКА если label_42 не определена
```

Ассемблер выдаст ошибку: `undefined label 'label_42'`.

### 6. Метка вне функции

Метки действуют только внутри своей функции. Нельзя прыгнуть
из одной функции в другую.

### 7. `ret` в конце каждой функции

Каждая функция **обязательно** должна заканчиваться инструкцией `ret`:

```asm
    ret 0    ; возврат без значения
    ; или
    ret 1    ; возврат со значением (верхушка стека)
```

---

## Шпаргалка по паттернам

### Чтение свойства
```asm
ldloc OBJ → ldattr "Property" → stloc DEST
```

### Запись свойства
```asm
ldloc OBJ → ldloc VALUE → stattr "Property"
```

### Вызов метода без возврата
```asm
ldloc ARG1 → [ldloc ARG2...] → ldglob "obj" → ldattr "Method" → call N → pop
```

### Условие if
```asm
[условие] → jz label_skip → [тело if] → label_skip:
```

### Условие if-else
```asm
[условие] → jz label_else → [тело if] → jmp label_end → label_else: → [тело else] → label_end:
```

### Сравнение с числом
```asm
ldloc VAR → ldfloat VALUE → cmpeq/cmpg/cmpge/cmpne → jz label
```

### Проверка на null
```asm
ldloc VAR → jz label_is_null
```

### Отладочный вывод
```asm
ldstr "format" → [значения...] → mklist N → ldglob "debug" → ldattr "LogInfo" → call 2 → pop
```
