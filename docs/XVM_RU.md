# Скриптовая система XVM — Mad Max

## Обзор

XVM (eXtensible Virtual Machine) — байткодовый скриптовый движок, используемый в игре Mad Max (Avalanche Studios, 2015). Игровые скрипты компилируются в файлы `.xvmc` — ADF-контейнеры, содержащие модули XVM-байткода. Данный набор инструментов обеспечивает полную декомпиляцию, компиляцию, дизассемблирование и ассемблирование XVM-скриптов.

Язык скриптов — Python-подобный: динамическая типизация, блоки по отступам, доступ к движковым глобалам (`vehicle`, `input`, `character` и т.д.).

---

## Содержание

1. [Быстрый старт](#быстрый-старт)
2. [Инструменты](#инструменты)
3. [Справочник языка XVM](#справочник-языка-xvm)
4. [Директивы компилятора](#директивы-компилятора)
5. [Движковые глобалы](#движковые-глобалы)
6. [Архитектура байткода](#архитектура-байткода)
7. [Формат контейнера ADF](#формат-контейнера-adf)
8. [Структура проекта](#структура-проекта)
9. [Рабочий процесс моддинга](#рабочий-процесс-моддинга)
10. [Известные отличия](#известные-отличия)
11. [Планы развития](#планы-развития)

---

## Быстрый старт

### Декомпилировать скрипт
```
Gibbed.MadMax.XvmDecompile.exe script.xvmc script.xvm
```

### Скомпилировать скрипт
```
Gibbed.MadMax.XvmCompile.exe script.xvm script.xvmc
```

### Дизассемблировать в листинг байткода
```
Gibbed.MadMax.XvmDisassemble.exe script.xvmc script.dis
```

### Ассемблировать из листинга байткода
```
Gibbed.MadMax.XvmAssemble.exe script.dis script.xvmc
```

### Полный пример round-trip
```bash
# 1. Извлечь .xvmc из архивов игры
# 2. Декомпилировать в читаемый исходный код
Gibbed.MadMax.XvmDecompile.exe veh_player_input.xvmc veh_player_input.xvm

# 3. Отредактировать файл .xvm

# 4. Скомпилировать обратно в байткод
Gibbed.MadMax.XvmCompile.exe veh_player_input.xvm veh_player_input.xvmc

# 5. Поместить в dropzone/scripts/gameobjects/vehicle/ для модификации игры
```

---

## Инструменты

### Gibbed.MadMax.XvmDecompile

Конвертирует байткод `.xvmc` в высокоуровневый исходный код `.xvm`.

```
Использование: Gibbed.MadMax.XvmDecompile.exe [ОПЦИИ] input.xvmc [output.xvm]

Опции:
  --hashes    Добавить директивы #! hash/source_hash для точного round-trip
  -h, --help  Показать справку
```

**Без `--hashes` (по умолчанию):** Создаёт чистый, читаемый исходный код. Хеши функций автоматически вычисляются из имён при рекомпиляции. Подходит для большинства задач моддинга.

**С `--hashes`:** Добавляет директивы `#! hash:` и `#! source_hash:` для сохранения оригинальных бинарных хешей. Требуется в случаях, когда хеш функции в оригинальном бинарнике не совпадает с Jenkins-хешем её имени (редко, случается когда Avalanche переименовывали функции без перекомпиляции).

### Gibbed.MadMax.XvmCompile

Конвертирует исходный код `.xvm` в байткод `.xvmc`.

```
Использование: Gibbed.MadMax.XvmCompile.exe [ОПЦИИ] input.xvm [output.xvmc]

Опции:
  -g, --globals=ПУТЬ  Путь к xvm_globals.txt (по умолчанию: рядом с exe)
  -h, --help          Показать справку
```

**Возможности:**
- Автоматическое вычисление хешей имён функций через Jenkins lookup3
- Автоматическое вычисление `source_hash` модуля из исходного текста (если не указан)
- Автоматическое вычисление `max_stack` через анализ потока данных
- Автоматическое вычисление количества `locals` по использованию переменных
- Генерация debug_info (строка:столбец для каждой инструкции)
- Свёртка констант для отрицательных float-литералов (`-1.0` как одна константа)

### Gibbed.MadMax.XvmDisassemble

Конвертирует `.xvmc` в низкоуровневый листинг `.dis`, показывающий отдельные инструкции байткода.

```
Использование: Gibbed.MadMax.XvmDisassemble.exe input.xvmc [output.dis]
```

### Gibbed.MadMax.XvmAssemble

Конвертирует листинг `.dis` обратно в байткод `.xvmc`.

```
Использование: Gibbed.MadMax.XvmAssemble.exe input.dis [output.xvmc]
```

---

## Справочник языка XVM

Исходный код XVM (файлы `.xvm`) использует Python-подобный синтаксис со значимыми отступами.

### Объявление модуля

```python
module my_script
import @58351C01
import @3BDB5A3B
```

- `module <имя>` — объявляет имя модуля (используется для вычисления хеша)
- `import @XXXXXXXX` — импортирует зависимый модуль по хешу

### Функции

```python
def FunctionName(self, arg1, arg2):
    # тело функции
    return value
```

- Первый параметр — по соглашению `self` (экземпляр игрового объекта)
- Все функции принимают аргументы через позиционные параметры
- Функции без явного `return` неявно не возвращают значение

### Типы данных

| Тип | Синтаксис | Пример |
|-----|-----------|--------|
| Float | Число с опциональной десятичной частью | `0`, `1.5`, `-3.14`, `0.001` |
| Bool | `true` / `false` | `true` |
| String | В двойных кавычках | `"hello"` |
| None | `none` | `none` |
| Bytes | `@` + шестнадцатеричные цифры | `@3B91D694` |
| List | Квадратные скобки | `[1, 2, 3]` |

**Примечание:** В XVM нет целочисленного типа. Все числа — 32-битные float. Значение `0` — это `0.0`, `1` — это `1.0` и т.д.

**Байтовые литералы** (`@XXXXXXXX`) обычно используются для хешированных имён событий/свойств, которые движок разрешает во время выполнения.

### Переменные

Переменные динамически типизированы и не требуют объявлений. Первое присваивание создаёт переменную:

```python
def Example(self):
    local1 = 42            # создаёт локальную переменную
    local2 = "hello"       # ещё одна локальная
    local1 = local2        # переприсваивание
```

### Операторы

**Арифметические:** `+`, `-`, `*`, `/`, `%`

**Сравнения:** `==`, `!=`, `>`, `>=`

**Логические:** `and`, `or`, `not`

**Унарные:** `-` (отрицание)

```python
result = (a + b) * 2
is_valid = x > 0 and y >= 0
flag = not condition
```

### Управление потоком выполнения

**if / elif / else:**
```python
if condition:
    do_something()
elif other_condition:
    do_other()
else:
    do_default()
```

**while:**
```python
while condition:
    do_work()
```

**return:**
```python
def Compute(self, x):
    if x > 0:
        return x * 2
    return -1
```

**pass:**
```python
def Placeholder(self):
    pass
```

**assert:**
```python
assert value > 0
```

### Доступ к атрибутам

```python
props = scriptgo.GetProperties(self)
props.rearViewEnabled = true
value = props.boost_enabled
```

### Доступ по индексу

```python
list = [1, 2, 3]
item = list[0]
list[1] = 42
```

### Вызовы методов

```python
# Вызовы API движка
result = vehicle.IsPlayerVehicle(car)
input.GetButtonInput(@3B91D694)

# Вызовы функций модуля
DisableBoost(self)

# Цепочки вызовов
character.GetPlayer().GetName()
```

### Комментарии

```python
# Это комментарий
x = 5  # строчный комментарий
```

---

## Директивы компилятора

Директивы компилятора используют префикс `#!` и обрабатываются перед лексическим анализом. Они распознаются только на нулевом уровне отступов (верхний уровень).

### source_hash

```python
module my_script
#! source_hash: 0x088AECE6
```

Принудительно задаёт значение поля `source_hash` модуля. Если не указано, компилятор автоматически вычисляет его через Jenkins-хеш исходного текста.

### hash (функция)

```python
#! hash: 0xBE988D2F
def DisableBoost(self):
    # ...
```

Принудительно задаёт хеш имени функции. Если не указано, компилятор автоматически вычисляет его через Jenkins-хеш имени функции.

**Когда использовать:** Только когда оригинальный хеш функции не совпадает с `Jenkins(имя)`. Это случается редко — когда оригинальный компилятор Avalanche использовал другое имя, которое позже было изменено в отладочных строках. Используйте флаг `--hashes` при декомпиляции для обнаружения и сохранения таких случаев.

---

## Движковые глобалы

Скрипты XVM получают доступ к функциональности движка через глобальные объекты. Компилятору необходимо знать, какие идентификаторы являются глобалами (загружаются через `ldglob`), а какие — локальными переменными (загружаются через `ldloc`).

Глобалы определяются в файле `xvm_globals.txt` (размещается рядом с исполняемым файлом компилятора или указывается через `--globals`):

```
# xvm_globals.txt

# Ядро движка
scriptgo        # Рантайм скриптов, GetProperties(), управление событиями
game            # Состояние игры, IsObjectEqualTo() и т.д.
input           # Система ввода, GetButtonInput(), GetAnalogInput()
gui             # Система GUI

# Системы сущностей
character       # Управление персонажами, GetPlayer()
vehicle         # Система транспорта, IsPlayerVehicle(), GetVehicleDriver()
animation       # Конечный автомат анимаций, GetStateBit()
physics         # Физический движок

# Математика / утилиты
math            # Математические функции
vector          # Векторные операции

# UI / камера / звук
ui              # Система UI
camera          # Управление камерой
sound           # Звуковая система
hud             # Элементы HUD

# Мир / сеть / таймер
world           # Управление миром
network         # Сеть/мультиплеер
timer           # Система таймеров
debug           # Отладочный вывод

# Библиотечные модули (скриптовые глобалы)
lib_entity_proxy
lib_player_input
lib_vehicle
```

### Типичные паттерны API

```python
# Получить свойства скрипта для игрового объекта
props = scriptgo.GetProperties(self)

# Проверить ввод кнопки по хешу
if input.GetButtonInput(@3B91D694) > 0:
    # кнопка нажата

# Операции с транспортом
if vehicle.IsPlayerVehicle(props.car):
    driver = vehicle.GetVehicleDriver(props.car)

# Проверки игрока
player = character.GetPlayer()
if game.IsObjectEqualTo(player, driver):
    # игрок за рулём

# Состояние анимации
state = animation.GetStateBit(anim_obj, 10.0)
```

---

## Архитектура байткода

### Формат инструкций

XVM использует 16-битные инструкции:
- **Биты 15-11:** Код операции (5 бит, 0-31)
- **Биты 10-0:** Операнд (11 бит, 0-2047)

```
[OOOOO|FFFFFFFFFFF]
  код    операнд
```

### Стековая машина

XVM — стековая виртуальная машина. Операции помещают и извлекают значения из стека вычислений.

### Коды операций

| Код | Мнемоника | Операнд | Эффект на стек | Описание |
|-----|-----------|---------|---------------|----------|
| 0 | `assert` | — | -1 | Проверить, что вершина стека истинна |
| 1 | `and` | — | -1 | Логическое И: извлечь 2, поместить результат |
| 2 | `or` | — | -1 | Логическое ИЛИ: извлечь 2, поместить результат |
| 3 | `add` | — | -1 | Сложение: извлечь 2, поместить сумму |
| 4 | `div` | — | -1 | Деление: извлечь 2, поместить частное |
| 5 | `mod` | — | -1 | Модуль: извлечь 2, поместить остаток |
| 6 | `mul` | — | -1 | Умножение: извлечь 2, поместить произведение |
| 7 | `sub` | — | -1 | Вычитание: извлечь 2, поместить разность |
| 8 | `mklist N` | количество | -(N-1) | Извлечь N элементов, поместить список |
| 9 | `call N` | кол-во арг. | -N | Извлечь вызываемый объект + N арг., поместить результат |
| 10 | `cmpeq` | — | -1 | Равно: извлечь 2, поместить bool |
| 11 | `cmpge` | — | -1 | Больше-равно: извлечь 2, поместить bool |
| 12 | `cmpg` | — | -1 | Больше: извлечь 2, поместить bool |
| 13 | `cmpne` | — | -1 | Не равно: извлечь 2, поместить bool |
| 14 | `jmp` | цель | 0 | Безусловный переход |
| 15 | `jz` | цель | -1 | Переход, если вершина стека ложна |
| 18 | `ldattr` | конст. | 0 | Загрузить атрибут: извлечь объект, поместить obj.attr |
| 19 | `ldconst` | конст. | +1 | Поместить константу (float/string/bytes/none) |
| 20 | `ldbool N` | 0/1 | +1 | Поместить логическое значение |
| 21 | `ldglob` | конст. | +1 | Поместить глобал по имени |
| 22 | `ldloc N` | слот | +1 | Поместить локальную переменную |
| 23 | `lditem` | — | -1 | Доступ по индексу: извлечь объект+индекс, поместить obj[idx] |
| 24 | `pop` | — | -1 | Отбросить вершину стека |
| 25 | `dbgout N` | — | переменный | Отладочный вывод |
| 26 | `ret N` | количество | -N | Возврат (0=без значения, 1=с значением) |
| 27 | `stattr` | конст. | -2 | Сохранить атрибут: извлечь объект+значение, задать obj.attr=val |
| 28 | `stloc N` | слот | -1 | Сохранить локальную переменную |
| 29 | `stitem` | — | -3 | Сохранить по индексу: извлечь obj+idx+val, задать obj[idx]=val |
| 30 | `not` | — | 0 | Логическое НЕ: заменить вершину стека |
| 31 | `neg` | — | 0 | Арифметическое отрицание: заменить вершину стека |

**Примечание:** Коды операций 16 и 17 не используются / зарезервированы.

### Соглашение о вызовах

```
push arg0          # первый аргумент
push arg1          # второй аргумент
push callable      # ссылка на функцию/метод
call 2             # вызов с 2 аргументами
```

Для вызовов методов (`obj.method(args)`):
```
push arg0
push obj
ldattr "method"    # разрешить метод
call 1             # вызов с 1 аргументом
```

### Соглашение о сохранении атрибутов

```
push value         # сохраняемое значение
push obj           # целевой объект
stattr "name"      # obj.name = value
```

### Таблица констант

На константы ссылаются по индексу операнда. Типы:
- **Float:** 32-битное число IEEE 754
- **String:** Текст UTF-8 с Jenkins-хешем
- **Bytes:** Сырые последовательности байтов (обычно хешированные имена)
- **None:** Одиночное значение null

### Буфер строк (StringBuffer)

Байтовый буфер, хранящий строковые данные и метаданные имён атрибутов. Каждая запись включает:
- Индекс хеша (ссылка на таблицу StringHashes)
- Смещения отладочных строк (для отладочных сборок)
- Собственно байты строки (с нулевым завершением)

### Алгоритм хеширования

XVM использует **Jenkins lookup3** (`hashlittle`) с seed=0 для всего хеширования имён:
- Хеш имени модуля
- Хеши имён функций
- Хеши строковых констант
- Хеши имён атрибутов/глобалов

---

## Формат контейнера ADF

Файлы `.xvmc` используют контейнер ADF (Avalanche Data Format):

### Заголовок ADF (0x40 байт)

| Смещение | Размер | Поле |
|----------|--------|------|
| 0x00 | 4 | Сигнатура: `0x41444620` ("ADF ") |
| 0x04 | 4 | Версия: `4` |
| 0x08 | 4 | Количество экземпляров |
| 0x0C | 4 | Смещение информации об экземплярах |
| 0x10 | 4 | Количество определений типов (0 для XVM) |
| 0x14 | 4 | Смещение определений типов |
| 0x18 | 8 | Зарезервировано (0) |
| 0x20 | 4 | Количество записей таблицы имён |
| 0x24 | 4 | Смещение таблицы имён |
| 0x28 | 4 | Общий размер |
| 0x2C | 20 | Зарезервировано (0) |

### Экземпляры ADF

Каждый `.xvmc` содержит 3 экземпляра:

| Экземпляр | Хеш типа | Описание |
|-----------|----------|----------|
| `module` | `0x41D02347` | Модуль байткода XVM |
| `debug_info` | `0xDCB06466` | Номера строк/столбцов для каждой инструкции |
| `debug_strings` | `0xFEF3B589` | Таблица отладочных строк |

### Запись информации об экземпляре (24 байта)

| Смещение | Размер | Поле |
|----------|--------|------|
| 0x00 | 4 | Хеш имени |
| 0x04 | 4 | Хеш типа |
| 0x08 | 4 | Смещение данных |
| 0x0C | 4 | Размер данных |
| 0x10 | 8 | Индекс имени |

---

## Структура проекта

```
Gibbed.MadMax/
  Gibbed.MadMax.FileFormats/     # Определения форматов
    XvmModule.cs                 #   Чтение/модель данных XVM-модуля
    XvmOpcode.cs                 #   Перечисление кодов операций (0-31)
    AdfFile.cs                   #   Чтение контейнера ADF
    StringHelpers.cs             #   Реализация хеша Jenkins lookup3

  Gibbed.MadMax.XvmScript/       # Общая библиотека AST
    Ast.cs                       #   Иерархия AST-узлов (Expr, Stmt, Module)
    AstPrinter.cs                #   AST -> исходный код

  Gibbed.MadMax.XvmDisassemble/  # Дизассемблер байткода (.xvmc -> .dis)
    Program.cs                   #   Точка входа CLI

  Gibbed.MadMax.XvmAssemble/     # Ассемблер байткода (.dis -> .xvmc)
    DisParser.cs                 #   Парсер .dis файлов -> IR ParsedModule
    Assembler.cs                 #   IR -> XvmModule (таблица констант, метки)
    XvmModuleWriter.cs           #   Бинарная сериализация XvmModule
    AdfWriter.cs                 #   Запись контейнера ADF
    HashUtil.cs                  #   Утилита хеширования

  Gibbed.MadMax.XvmDecompile/    # Декомпилятор (.xvmc -> .xvm)
    Program.cs                   #   Точка входа CLI
    InstructionDecoder.cs        #   Сырой байткод -> декодированные инструкции
    CfgBuilder.cs                #   Построение графа потока управления
    ExpressionRecovery.cs        #   Симуляция стека -> AST-выражения
    StructuralAnalysis.cs        #   CFG -> восстановление if/while/else

  Gibbed.MadMax.XvmCompile/      # Компилятор (.xvm -> .xvmc)
    Program.cs                   #   Точка входа CLI + предпарсинг директив
    Lexer.cs                     #   Исходный код -> токены (на основе отступов)
    Token.cs                     #   Типы токенов
    Parser.cs                    #   Токены -> AST (рекурсивный спуск)
    SemanticAnalysis.cs          #   Разрешение областей видимости переменных
    CodeGenerator.cs             #   AST -> IR ассемблера (ParsedModule)

  bin/
    xvm_globals.txt              # Файл определения движковых глобалов
```

### Конвейер компиляции

```
Исходный код .xvm
    |
    v
[Лексер] -> токены
    |
    v
[Парсер] -> AST (ScriptModule)
    |
    v
[Семантический анализ] -> области видимости переменных
    |
    v
[Генератор кода] -> ParsedModule (IR ассемблера)
    |
    v
[Ассемблер] -> XvmModule + отладочные данные
    |
    v
[AdfWriter] -> бинарный .xvmc
```

### Конвейер декомпиляции

```
Бинарный .xvmc
    |
    v
[AdfFile] -> экземпляры ADF
    |
    v
[XvmModule.Deserialize] -> модуль + функции + константы
    |
    v
[InstructionDecoder] -> декодированные инструкции
    |
    v
[CfgBuilder] -> базовые блоки + рёбра
    |
    v
[ExpressionRecovery] -> AST-выражения для каждого блока
    |
    v
[StructuralAnalysis] -> восстановление if/while/else
    |
    v
[AstPrinter] -> исходный код .xvm
```

---

## Рабочий процесс моддинга

### Установка модов

Mad Max поддерживает папку `dropzone` для переопределения файлов:

```
<Папка установки Mad Max>/dropzone/scripts/gameobjects/vehicle/veh_player_input.xvmc
```

Файлы в `dropzone/` переопределяют соответствующие файлы из игровых архивов.

### Типичный рабочий процесс

1. **Извлечь** файл `.xvmc` из игровых архивов с помощью `Gibbed.MadMax.SmallUnpack`
2. **Декомпилировать** в исходный код `.xvm`:
   ```
   Gibbed.MadMax.XvmDecompile.exe original.xvmc script.xvm
   ```
3. **Отредактировать** файл `.xvm` в любом текстовом редакторе
4. **Скомпилировать** обратно:
   ```
   Gibbed.MadMax.XvmCompile.exe script.xvm modified.xvmc
   ```
5. **Поместить** `.xvmc` в соответствующий подкаталог `dropzone/`

### Советы

- Используйте `--hashes` при декомпиляции, если нужно точное воспроизведение бинарника
- Файл `xvm_globals.txt` должен находиться рядом с исполняемым файлом компилятора или указываться через `--globals`
- После компиляции можно проверить результат дизассемблером:
  ```
  Gibbed.MadMax.XvmDisassemble.exe modified.xvmc check.dis
  ```
- Компилятор автоматически генерирует debug_info — игра использует его для отчётов об ошибках

---

## Известные отличия

При round-trip через декомпиляцию/компиляцию возможны следующие нефункциональные отличия от оригинального бинарника:

| Аспект | Оригинал | После round-trip | Влияние |
|--------|----------|-----------------|---------|
| Порядок констант | Бинарный порядок | Порядок первого появления | Нет |
| Компоновка StringBuffer | Перекрывающиеся записи | Неперекрывающиеся | Нет (файл меньше) |
| max_stack | Завышенные оценки | Точно вычисленные | Нет (игре нужно >= реального) |
| Количество хешей строк | Включает артефакты перекрытия | Только используемые хеши | Нет |
| source_hash | Оригинальное значение | Jenkins(исходный текст) | Нет (если не указан `#! source_hash:`) |

Все отличия **функционально эквивалентны** — поведение в игре идентично.

---

## Планы развития

### Расширение VSCode

Планируется разработка расширения для Visual Studio Code для работы с XVM:

**Подсветка синтаксиса**
- Полная грамматика для файлов `.xvm`
- Подсветка ключевых слов (`def`, `if`, `elif`, `else`, `while`, `return`, `assert`, `pass`, `and`, `or`, `not`, `true`, `false`, `none`, `module`, `import`)
- Подсветка строк, чисел, байтовых литералов и комментариев
- Подсветка директив `#!`

**Быстрая компиляция**
- Компиляция `.xvm` в `.xvmc` прямо из редактора
- Горячая клавиша для компиляции одним нажатием (например, `Ctrl+Shift+B`)
- Отображение ошибок компилятора прямо в редакторе
- Автоматическое размещение в папке `dropzone/`

**Встроенный справочник API**
- IntelliSense/автодополнение для движковых глобалов и их методов:
  - `scriptgo.GetProperties()`, `scriptgo.SetProperties()`, ...
  - `vehicle.IsPlayerVehicle()`, `vehicle.GetVehicleDriver()`, ...
  - `input.GetButtonInput()`, `input.GetAnalogInput()`, ...
  - `character.GetPlayer()`, ...
  - `animation.GetStateBit()`, ...
  - `game.IsObjectEqualTo()`, ...
- Документация при наведении для методов API
- Подсказки параметров и информация о типах
- Автодополнение атрибутов глобалов (например, `props.rearViewEnabled`, `props.boost_enabled`)

**Расширенный формат `xvm_globals.txt`**
Планируется доработка формата для поддержки определений методов и атрибутов:

```
# Будущий формат xvm_globals.txt
[scriptgo]
  .GetProperties(obj) -> Properties
  .SetProperties(obj, props)

[vehicle]
  .IsPlayerVehicle(car) -> bool
  .GetVehicleDriver(car) -> Entity
  .GetVehiclePassenger(car, seat) -> Entity

[input]
  .GetButtonInput(hash) -> float
  .GetAnalogInput(hash) -> float

[character]
  .GetPlayer() -> Entity

[game]
  .IsObjectEqualTo(a, b) -> bool

[animation]
  .GetStateBit(obj, bit) -> float
```

Это позволит компилятору валидировать вызовы методов и выдавать осмысленные сообщения об ошибках при неправильном использовании API.
